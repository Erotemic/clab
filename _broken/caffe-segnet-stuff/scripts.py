

def fit(train_ims, train_gts, pretrained, arch='segnet_proper', task='DivaV1',
        workdir='./out', hyperparams=None):
    r"""
    Trains weights for a semantic segmentation architecture

    Notes:
        All output is tagged with a hash indicating its input dependencies
        (similar got git's blockchain). Thus, the same workdir can be used for
        training models with different data and different hyperparams.

    Args:
        test_ims (list or str): list of image paths or a directory of images
        test_gts (list or str): list of image paths or a directory of images
        pretrained (str): pretrained weights used to initialize the network
        arch (str): specifies which segmentation architecture to use
           options: [segnet_proper, segnet_basic]
        task (str): specifies which labels will be used
        workdir (str): directory for intermediate files
        hyperparams (dict): dictionary of hyperparameters

    Returns:
        str: test_weights_fpath : weights suitable for test and deployment
    """
    import pysseg
    import six
    harn = pysseg.Harness(workdir=workdir, arch=arch)
    # The task can be specified as a string or an instance of the class
    if isinstance(task, six.string_types):
        harn.task = getattr(pysseg.tasks, task)()
    else:
        harn.task = task
    harn.init_pretrained_fpath = pretrained
    harn.train.set_ims(train_ims)
    harn.train.set_gts(train_gts)
    if hyperparams is not None:
        harn.params.update(hyperparams)
    harn.prepare_solver()
    harn.fit()
    # Get all weights resulting from fit and pick the most recent
    snapshot_weights = harn.snapshot_weights()
    train_weights_path = snapshot_weights[-1]
    # Apply batch-normalization post-processing to make deployable weights
    test_weights_fpath = harn.postprocess_training_weights(
        train_weights_path=train_weights_path)
    print('test_weights_fpath = {!r}'.format(test_weights_fpath))
    return test_weights_fpath


def predict(test_ims, weights_fpath, model_fpath=None, arch='segnet_proper',
            task='DivaV1', workdir='./out', test_gts=None):
    r"""
    Does a forward pass through the network with the test images.  The raw
    output is dumped into <workdir>/pred and other output, such as
    visualizations, are dumped in neighboring directories. (e.g.
    <workdir>/pred_blend)

    Args:
        test_ims (list or str): list of image paths or a directory of images
        model_fpath (str): path to a the model used to train the weights
           optional, unless an external tool was used to train the weights.
        weights_fpath (str): path to the .caffe weights associated with the model
        task (str): specifies which labels will be used
        workdir (str): directory for intermediate files
        test_gts (list or str): list of image paths or a directory of images
           (caffe requires these for some reason... probably a workaround)
    """
    import pysseg
    import six
    from os.path import join

    harn = pysseg.Harness(workdir=workdir, arch=arch)
    if isinstance(task, six.string_types):
        harn.task = getattr(pysseg.tasks, task)()
    else:
        harn.task = task

    harn.test.set_ims(test_ims)
    assert test_gts is not None, (
        'caffe requires test_gts in prediction for some reason')
    if test_gts:
        harn.test.get_gts(test_gts)

    harn.prepare_test_model()
    # The autogenerated model may have different layer names even though it is
    # the same architecture. This conversion simply forces caffe to apply
    # weights correctly.
    if model_fpath is not None:
        # FIXME: this will segfault if the model inputs are missing.  This is
        # fixed in a later version of caffe, but not caffe-segnet
        harn.test_weights_fpath = harn.convert_weights(model_fpath, weights_fpath)
    else:
        harn.test_weights_fpath = weights_fpath

    # This var specifies where predictions will be dumped (needs a name change)
    harn.test_dump_dpath = harn.workdir
    harn.predict()

    pred_dpath = join(harn.test_dump_dpath, 'pred')
    print('Output predictions = {!r}'.format(pred_dpath))
    return pred_dpath


def score(pred_ims, test_gts, task='DivaV1', workdir='./out', true_task=None):
    """
    Checks the predictions against groundtruth, builds a confusion matrix, and
    calculates metrics such as mIoU (jaccard score). Results are written to a
    file, and the path to this file is returned.
    """
    import six
    import pysseg
    from pysseg.util import imutil

    harn = pysseg.Harness(workdir=workdir)
    if isinstance(task, six.string_types):
        harn.task = getattr(pysseg.tasks, task)()
    else:
        harn.task = task
    harn.test.get_gts(test_gts)

    if task == true_task:
        true_task = None

    if true_task is not None:
        if isinstance(true_task, six.string_types):
            true_task = getattr(pysseg.tasks, true_task)()

    harn.test_dump_dpath = harn.workdir

    if isinstance(pred_ims, list):
        pred_paths = pred_ims
    else:
        pred_paths = imutil.load_image_paths(pred_ims, ext='.png')
    harn.test.prepare_truth()

    gt_paths = harn.test.gt_paths

    results_fpath = harn._score(gt_paths, pred_paths, true_task=true_task)
    print('results_fpath = {!r}'.format(results_fpath))
    return results_fpath


if __name__ == '__main__':
    import sys
    funcname = sys.argv[1]
    func = vars()[funcname]
    func(*sys.argv[2:])
